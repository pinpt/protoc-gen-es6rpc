package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strconv"
	"strings"
	"text/template"
	"time"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
)

func strp(v string) *string {
	return &v
}

func extractComments(file *descriptor.FileDescriptorProto) map[string]*descriptor.SourceCodeInfo_Location {
	comments := make(map[string]*descriptor.SourceCodeInfo_Location)
	for _, loc := range file.GetSourceCodeInfo().GetLocation() {
		if loc.LeadingComments == nil {
			continue
		}
		var p []string
		for _, n := range loc.Path {
			p = append(p, strconv.Itoa(int(n)))
		}
		comments[strings.Join(p, ",")] = loc
	}
	return comments
}

func getServicePath(serviceIndex int) string {
	return fmt.Sprintf("6,%d", serviceIndex)
}

func getMessagePath(messageIndex int) string {
	return fmt.Sprintf("4,%d", messageIndex)
}

func getFieldPath(messageIndex int, fieldIndex int) string {
	return fmt.Sprintf("4,%d,2,%d", messageIndex, fieldIndex)
}

func messageComment(index int, comments map[string]*descriptor.SourceCodeInfo_Location) string {
	k := getMessagePath(index)
	c := comments[k]
	return strings.TrimRight(c.GetLeadingComments(), "\n")
}

func buildArgsObject() string {
	//TODO: add the input type for a input type and build out the arguments object
	//with default values (if any) and should look like this:
	//{foo:default, bar:null}
	return ""
}

func main() {
	log.SetFlags(255)
	b, err := ioutil.ReadAll(os.Stdin)
	if err != nil {
		log.Fatalln(err)
	}
	req := new(plugin.CodeGeneratorRequest)
	err = proto.Unmarshal(b, req)
	if err != nil {
		log.Fatalln(err)
	}
	p := req.GetParameter()
	// turn incoming params into a map that makes it easy to support arbitray key/value pairs for config
	params := make(map[string]string)
	if p != "" {
		tok := strings.Split(p, ",")
		for _, t := range tok {
			stok := strings.Split(t, "=")
			params[stok[0]] = stok[1]
		}
	}
	apiprefix := params["apiprefix"]
	if apiprefix == "" {
		apiprefix = "/api"
	}
	resp := &plugin.CodeGeneratorResponse{
		File: make([]*plugin.CodeGeneratorResponse_File, 0),
	}
	tmpl := template.New("es6")
	tmpl = tmpl.Funcs(map[string]interface{}{
		"messageComment":  messageComment,
		"buildArgsObject": buildArgsObject,
	})
	tmpl, err = tmpl.Parse(es6template)
	if err != nil {
		log.Fatalln(err)
	}
	htmpl, err := template.New("header").Parse(headerTemplate)
	if err != nil {
		log.Fatalln(err)
	}
	date := time.Now().Format(time.ANSIC)
	var buf bytes.Buffer
	for index, filename := range req.FileToGenerate {
		buf.Reset()
		htmpl.Execute(&buf, map[string]string{
			"filename": filename,
			"date":     date,
		})
		header := buf.String()
		buf.Reset()
		for sindex, service := range req.ProtoFile[index].Service {
			comments := extractComments(req.ProtoFile[index])
			err := tmpl.Execute(&buf, map[string]interface{}{
				"header":    header,
				"apiprefix": apiprefix,
				"filename":  filename,
				"service":   service,
				"comment":   strings.TrimRight(comments[getServicePath(sindex)].GetLeadingComments(), "\n"),
				"comments":  comments,
			})
			if err != nil {
				log.Fatalln(err)
			}
			resp.File = append(resp.File, &plugin.CodeGeneratorResponse_File{
				Name:    strp(service.GetName() + ".js"),
				Content: strp(buf.String()),
			})
		}
	}
	ob, err := proto.Marshal(resp)
	if err != nil {
		log.Fatalln(err)
	}
	os.Stdout.Write(ob)
}

const headerTemplate = `// Code generated by protoc-gen-es6rpc
// WARNING: DO NOT HAND IT THIS OR YOU WILL LOSE CHANGES
// Generated from {{ .filename }} on {{ .date }}

import Axios from 'axios';`

const es6template = `{{ .header }}

{{ $comments := .comments -}}
{{ $apiprefix := .apiprefix -}}

// {{ .comment }}
export default class {{ .service.Name }} {
	constructor() {
	}
{{ range $i, $method := .service.Method }}
	{{ with $method -}}
	// {{ messageComment $i $comments}}
	static {{.Name}}({{ buildArgsObject }}) {
		const data = {
		};
		return Axios.post('{{$apiprefix}}/{{.Name}}', data);
	}
	{{- end }}
{{- end }}
}
`
